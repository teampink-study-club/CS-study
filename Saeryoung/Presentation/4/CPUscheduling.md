# 다단계 큐 vs 다단계 피드백 큐 스케줄링

## 1. 다단계 큐 (Multilevel Queue) 스케줄링

### 기본 개념

- 프로세스들을 **미리 정해진 그룹**으로 분류하여 여러 개의 큐에 배치
- 각 큐마다 다른 스케줄링 알고리즘 사용
- 프로세스는 **한 번 배정된 큐에서 이동하지 않음** (고정적)

### 큐 구조 예시

```
[우선순위 높음]
큐 1: 시스템 프로세스      (FCFS 사용)
│ └─ 커널, 드라이버, 인터럽트 핸들러
│
큐 2: 대화형 프로세스      (Round Robin 사용)
│ └─ 텍스트 에디터, 웹브라우저, 게임
│
큐 3: 배치 프로세스        (FCFS 사용)
│ └─ 컴파일러, 백업 프로그램, 데이터 분석
[우선순위 낮음]
```

### 간단한 예시

**상황:** 컴퓨터에서 동시에 실행 중

- 🖱️ 마우스 드라이버 → 시스템 큐 (최우선)
- 💻 메모장 → 대화형 큐
- 🔄 바이러스 스캔 → 배치 큐 (후순위)

**결과:** 마우스를 움직이면 다른 모든 작업을 멈추고 마우스 처리부터!

### 장단점

**장점**

- 구현이 간단함
- 중요한 시스템 프로세스 우선 처리 보장
- 예측 가능한 성능

**단점**

- 유연성 부족 (한번 분류되면 고정)
- 낮은 우선순위 큐에서 기아 현상 발생 가능
- 프로세스 특성이 변해도 반영 안됨

---

## 2. 다단계 피드백 큐 (Multilevel Feedback Queue) 스케줄링

### 기본 개념

- 프로세스들이 **동적으로** 큐 간을 이동할 수 있음
- 실행 결과에 따라 우선순위가 변함
- CPU 사용 패턴을 학습하여 적응적으로 스케줄링

### 큐 구조 예시

```
큐 0: 타임퀀텀 8ms    (Round Robin)
│ └─ 새로 도착한 모든 프로세스
│     ↓ (시간 초과시 강등)
│
큐 1: 타임퀀텀 16ms   (Round Robin)
│ └─ 중간 우선순위 프로세스
│     ↓ (시간 초과시 강등)
│
큐 2: FCFS
│ └─ 낮은 우선순위 프로세스 (CPU 집약적)
```

### 간단한 예시

**상황:** 새로운 프로세스 P1 실행

1. **처음:** P1이 큐 0에 배치 (8ms 할당)
2. **8ms 후:** 작업이 끝나지 않아서 큐 1로 강등 (16ms 할당)
3. **16ms 후:** 여전히 안 끝나서 큐 2로 강등 (FCFS로 처리)

**결과:** 짧은 작업은 빨리 끝나고, 긴 작업은 자동으로 배치 처리로!

### 이동 규칙

- **하향 이동:** 할당된 시간을 다 쓰면 낮은 큐로 이동
- **상향 이동:** I/O 대기 후 복귀 시 높은 큐로 이동 (선택사항)
- **에이징:** 오래 기다린 프로세스를 높은 큐로 승격

### 장단점

**장점**

- 유연성이 높음 (적응적)
- 짧은 작업에게 좋은 응답시간 제공
- 기아 현상 방지 가능 (에이징 기법 사용)
- I/O 집약적 vs CPU 집약적 프로세스 자동 구분

**단점**

- 구현이 복잡함
- 오버헤드가 큼 (큐 간 이동 비용)
- 매개변수 조정이 어려움

---

## 3. 핵심 차이점 비교

| 구분          | 다단계 큐                   | 다단계 피드백 큐             |
| ------------- | --------------------------- | ---------------------------- |
| **이동성**    | 고정적 (이동 없음)          | 동적 (큐 간 이동)            |
| **분류 기준** | 프로세스 유형으로 미리 분류 | 실행 동작에 따라 분류        |
| **복잡도**    | 간단함                      | 복잡함                       |
| **적응성**    | 없음                        | 높음                         |
| **기아 현상** | 발생 가능                   | 방지 가능                    |
| **사용 예**   | 단순한 시스템               | 일반적인 OS (Windows, Linux) |

---

## 4. 실제 사용 예시

### Windows의 스케줄링

- 다단계 피드백 큐 방식 사용
- 32개 우선순위 레벨
- 대화형 작업에 높은 우선순위 부여

### Linux의 CFS (Completely Fair Scheduler)

- 피드백 개념을 발전시킨 형태
- 가상 런타임을 사용해 공정성 보장
- Red-Black Tree로 효율적 구현

**결론:** 다단계 피드백 큐가 더 복잡하지만 실제 시스템에서는 이 방식이 더 효율적이어서 널리 사용됩니다!
