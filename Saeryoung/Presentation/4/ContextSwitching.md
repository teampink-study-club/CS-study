# 문맥교환

문맥 교환(Context Switching)은 CPU가 현재 실행 중인 프로세스에서 다른 프로세스로 실행을 전환하는 과정  
멀티태스킹 운영체제에서 여러 프로세스가 CPU를 공유할 수 있도록 하는 핵심 메커니즘!

## 문맥 교환 발생 시점

### 자발적 문맥 교환

- **시스템 콜 호출**: I/O 요청, 메모리 할당 등
- **대기 상태 진입**: 자원 대기, 동기화 객체 대기
- **프로세스 종료**: exit() 호출

### 비자발적 문맥 교환

- **시간 할당량 만료**: 라운드 로빈 스케줄링에서 타임 슬라이스 종료
- **인터럽트 발생**: I/O 완료, 타이머 인터럽트
- **높은 우선순위 프로세스 등장**: 선점형 스케줄링
- **예외 발생**: 페이지 폴트, 보호 위반 등

## 문맥 교환 과정

1. **인터럽트 또는 시스템 콜 발생**

- 현재 실행 중인 프로세스 중단
- 커널 모드로 전환

2. **현재 프로세스 상태 저장**

- 레지스터 값을 PCB에 저장
- 프로그램 카운터, 스택 포인터 저장
- 메모리 관리 정보 저장

3. **스케줄러 호출**

- 다음 실행할 프로세스 선택
- 스케줄링 알고리즘에 따른 결정

4. **새로운 프로세스 상태 복원**

- 선택된 프로세스의 PCB에서 정보 로드
- 레지스터, 메모리 관리 정보 복원
- 프로그램 카운터를 새 프로세스 위치로 설정

5. **새로운 프로세스 실행 시작**

- 사용자 모드로 전환
- 새 프로세스의 명령어 실행 재개

<br>

## Context-Switching 인터럽트

- I/O Request(입출력요청)
- Time-Slice Expired(CPU 사용시간 만료)
- Fork a child(자식 프로세스 생성)
- Wait for an interrupt(인터럽트 대기)

<br>

## Context Switching의 한계점

**성능 한계**

- 오버헤드 누적: 빈번한 문맥 교환으로 인한 실제 작업 시간 감소

  - 일반적으로 문맥 교환 시간은 1-100μs 범위
  - 높은 빈도 시 전체 CPU 시간의 상당 부분을 소비

- 스케일링 한계: 프로세스/쓰레드 수 증가에 따른 성능 저하
  - O(n) 복잡도의 스케줄링 알고리즘 한계
  - 메모리 사용량 증가 (PCB, 스택 공간)

**캐시 효율성 문제**

- 캐시 오염(Cache Pollution): 새로운 프로세스 데이터로 인한 기존 캐시 무효화
  - 공간 지역성 손실: 프로세스 간 메모리 접근 패턴 차이
  - 시간 지역성 저하: 문맥 교환으로 인한 데이터 재사용 기회 감소

**실시간 시스템의 한계**

- 비결정적 지연: 문맥 교환 시간의 변동성
- 우선순위 역전: 높은 우선순위 작업이 낮은 우선순위 작업에 의해 지연
- 데드라인 미스: 예측 불가능한 문맥 교환으로 인한 시간 제약 위반

**메모리 관련 한계**

- 메모리 단편화: 프로세스별 메모리 할당으로 인한 공간 낭비
- 가상 메모리 오버헤드: 페이지 테이블 관리 및 주소 변환 비용
- 메모리 보호 비용: 프로세스 간 격리를 위한 추가 검사

**동기화 복잡성**

- 경쟁 조건: 공유 자원에 대한 동시 접근 문제
- 데드락 위험: 잘못된 동기화로 인한 시스템 정지
- 라이브락: 지속적인 재시도로 인한 진전 없음

<br>

## 최적화 전략

**설계 차원**

- 적절한 시간 할당량 설정: 너무 작으면 오버헤드, 너무 크면 응답성 저하
- 효율적인 스케줄링 알고리즘: 우선순위 기반, 다단계 피드백 큐
- 프로세스 vs 쓰레드 선택: 작업 특성에 맞는 동시성 모델

**시스템 차원**

- CPU 친화도(Affinity) 설정: 캐시 지역성 향상
- NUMA 인식 스케줄링: 메모리 접근 최적화
- 인터럽트 처리 최적화: 불필요한 문맥 교환 방지
