# Chap 11. CPU 스케줄링

## 01. CPU 스케줄링 개요

### 프로세스 우선순위

**입출력 집중 프로세스**

- 비디오 재생, 디스크 백업 작업 등을 담당하는 프로세스
- 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무름

**CPU 집중 프로세스**

- 복잡한 수학 연산, 컴파일, 그래픽 처리 작업 등을 담당하는 프로세스
- 대기 상태보다는 실행 상태에 더 많이 머무름

> CPU 버스트와 입출력 버스트
>
> - CPU 버스트 : CPU를 이용하는 작업
> - 입출력 버스트 : 입출력장치를 기다리는 작업  
>   → 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행

⚡️ 입출력 집중 프로세스를 먼저 실행시켜 CPU를 빨리 사용하고 대기 상태로 만든 뒤, CPU 집중 프로세스를 실행시키는 것이 더 효율적 !!

상황에 맞게, 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 `우선순위` 부여, PCB에 명시

### 스케줄링 큐

CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들 등 프로세스들에 '줄을 서서 기다릴 것'을 요구 = `스케줄링 큐`

운영체제는 메모리로 적재되고 싶은 (새로 생성되는) 프로세스들을 큐에 삽입하여 줄 세우고, CPU를 이용하고 싶은 프로세스들도 큐에 삽입하여 줄 세우고, 특정 입출력장치를 이용하고 싶은 프로세스들도 큐에 삽입하여 줄 세움

⚡️ 운영체제가 관리하는 대부분의 자원은 큐로 관리  
`준비 큐` = CPU를 이용하고 싶은 프로세스들이 서는 줄  
`대기 큐` = 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄

### 선점형과 비선점형 스케줄링

**선점형 스케줄링**  
프로세스가 CPU를 비롯한 자원을 사용하고 있더라고 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식  
→ 어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식  
프로세스들에 골고루 자원 배분, but 문맥 교환 과정에서 오버헤드 발생 가능성

**비선점형 스케줄링**  
하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식  
→ 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식  
모든 프로세스가 골고루 자원 사용을 못한다는 단점, but 문맥 교환 오버헤드 발생 가능성 낮음

⚡️ 현재 대부분의 운영체제는 선점형 스케줄링 방식 차용

<br>

## 02. CPU 스케줄링 알고리즘

### 스케줄링 알고맂므의 종류

**[선입 선처리 스케줄링]**  
FCFS 스케줄링 = First Come first Served Scheduling  
단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식  
→ CPU를 먼저 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식

✽ **호위 효과**  
CPU를 오래 사용하는 프로세스가 먼저 큐에 삽입되면 다른 프로세스는 그 프로세스가 CPU를 사용하는 동안 무작정 기다려야 함

**[최단 작업 우선 스케줄링]**  
SJF 스케줄링 = Shortest Job First Scheduling
준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행  
→ 호위 효과 방지  
→ 기본적으로 비선점형 스케줄링 알고리즘으로 분류, 선점형으로 구현될 수도 있음

**[라운드 로빈 스케줄링]**  
선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식  
`타임 슬라이스` = 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미

→ 라운드 로빈 스케줄링은 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링  
⚡️ 라운드 로빈 스케줄링에서는 타임 슬라이스의 크기가 매우 중요

**[최소 잔여 시간 우선 스케줄링]**  
SRT 스케줄링 = Shortest Remaining Time Scheduling  
최단 작업 우선 스케줄링 알고리즘 + 라운드 로빈 알고리즘을 합친 스케줄링 방식  
→ 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택

**[우선순위 스케줄링]**  
✽ 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링

- 최단 작업 우선 스케줄링, 최소 잔여 시간 우선 스케줄링 알고리즘은 넓은 의미에서 우선순위 스케줄링의 일종으로 볼 수 있음
- 최단 작업 우선 스케줄링 : 짧은 프로세스에 높은 우선순위 부여
- 최소 잔여 시간 우선 스케줄링 : 남은 시간이 짧은 프로세스에 높은 우선순위 부여

🚨 우선순위 스케줄링의 근본적인 문제  
우선순위가 높은 프로세스를 우선하여 처리하는 방식이기 때문에 우선순위가 낮은 프로세스는 실행이 계속 연기될 수 있음 = `기아 현상 starvation`

⭐️ **에이징 Aging**  
기아 현상을 방지하기 위한 대표적인 기법

- 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
- 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법

**[다단계 큐 스케줄링]**

- 우선순위 스케줄링의 발전된 형태
- 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
- 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해짐
- 큐별로 타임 슬라이스를 여러 개 지정할 수도 있음
- 큐마다 다른 스케줄링 알고리즘 사용 가능

**[다단계 피드백 큐 스케줄링]**  
다단계 큐 스케줄링의 발전된 형태  
다단계 큐 스케줄링에서는 프로세스들이 큐 사이 이동 불가 → 기아 현상 발생 가능

다단계 피드백 큐 스케줄링은 큐 사이 이동 가능 !!  
→ 새로 준비 상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간 동안 실행

즉, CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고,
CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행

⚡️ 다단계 피드백 큐 스케줄링은 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘
